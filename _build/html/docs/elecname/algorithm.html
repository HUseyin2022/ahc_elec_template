<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Distributed Algorithm Name &mdash; Distributed Algorithm on AHCv2: elecname V1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=f2281d4f"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Implementation, Results and Discussion" href="results.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Distributed Algorithm on AHCv2: elecname
          </a>
              <div class="version">
                V1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="elecname.html">|DistAlgName|</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="abstract.html">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Distributed Algorithm Name</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background-and-related-work">Background and Related Work</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributed-algorithm-elecname">Distributed Algorithm: Distributed Algorithm Name</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#correctness">Correctness</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complexity">Complexity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="results.html">Implementation, Results and Discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../rubric.html">Assessment Rubric</a></li>
<li class="toctree-l1"><a class="reference internal" href="code.html">Code Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Distributed Algorithm on AHCv2: elecname</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="elecname.html">|DistAlgName|</a></li>
      <li class="breadcrumb-item active">Distributed Algorithm Name</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="elecname">
<h1>Distributed Algorithm Name<a class="headerlink" href="#elecname" title="Link to this heading"></a></h1>
<section id="background-and-related-work">
<h2>Background and Related Work<a class="headerlink" href="#background-and-related-work" title="Link to this heading"></a></h2>
<p>Present any background information survey the related work. Provide citations.</p>
</section>
<section id="distributed-algorithm-elecname">
<h2>Distributed Algorithm: Distributed Algorithm Name<a class="headerlink" href="#distributed-algorithm-elecname" title="Link to this heading"></a></h2>
<p>An example distributed algorithm for broadcasting on an undirected graph is presented in  <a class="reference internal" href="#blindfloodingalgorithmlabel"><span class="std std-ref">Algorithm</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="id4">
<span id="blindfloodingalgorithmlabel"></span><div class="code-block-caption"><span class="caption-text">Blind flooding algorithm.</span><a class="headerlink" href="#id4" title="Link to this code"></a></div>
<div class="highlight-RST notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>Implements: BlindFlooding Instance: cf
<span class="linenos"> 2</span>Uses: LinkLayerBroadcast Instance: lbc
<span class="linenos"> 3</span>Events: Init, MessageFromTop, MessageFromBottom
<span class="linenos"> 4</span>Needs:
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>OnInit: () do
<span class="linenos"> 7</span>
<span class="linenos"> 8</span>OnMessageFromBottom: ( m ) do
<span class="linenos"> 9</span>    Trigger lbc.Broadcast ( m )
<span class="linenos">10</span>
<span class="linenos">11</span>OnMessageFromTop: ( m ) do
<span class="linenos">12</span>    Trigger lbc.Broadcast ( m )
</pre></div>
</div>
</div>
<p>Do not forget to explain the algorithm line by line in the text.</p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h2>
<p>Provide an example for the distributed algorithm.</p>
</section>
<section id="correctness">
<h2>Correctness<a class="headerlink" href="#correctness" title="Link to this heading"></a></h2>
<p>Present Correctness, safety, liveness and fairness proofs.</p>
</section>
<section id="complexity">
<h2>Complexity<a class="headerlink" href="#complexity" title="Link to this heading"></a></h2>
<p>Present theoretic complexity results in terms of number of messages and computational complexity.</p>
<p>Election algorithm provides that each process has the same local algorithm, it is decentralized meaning a computation can be initialized by an arbitrary non empty subset of the process. The algorithm reaches a configuration defining one process is the state leader and others are state lost.
It is needed to be studied under assumptions such as the system is full y asynchronous and identified by a unique name.
In this section, election algorithms, focusing on two ones: the Ring Election: Dolev-Klawe-Rodeh algorithm and the Echo algorithm with extinction algorithm. We will present the principles behind these algorithms, their implementation details, and compare their strengths and weaknesses.</p>
<p>The Dolev-Klawe-Rodeh algorithm uses directed rings which messages cannot travel in both directions. Active process whose ID is p and next active neighbors are q and r. The Ids are collected at r. There are three cases to evaluate the election process.
If p&gt;q and r; r remains active and progress to the next election round
if p&lt;q or r; r becomes passive
if p=q and r; r becomes the leader</p>
<p>In the algorithm processes need to keep track of the parity of their current round number.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id5">
<span id="dolevklawerodehalgorithm"></span><div class="code-block-caption"><span class="caption-text">Dolev-Klawe-Rodeh Algorithm <a class="reference internal" href="#fokking2013" id="id1"><span>[Fokking2013]</span></a>.</span><a class="headerlink" href="#id5" title="Link to this code"></a></div>
<div class="highlight-RST notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>bool Activep, leaderp, parityp;
<span class="linenos"> 2</span>proc election-idp, neighb-id[idp] for n=0,1 and Booleans b;
<span class="linenos"> 3</span>
<span class="linenos"> 4</span>If p is an initiator
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>active ← true; election-id ← p;
<span class="linenos"> 7</span>send &lt;id,p,0,b&gt;;
<span class="linenos"> 8</span>
<span class="linenos"> 9</span>If p receives &lt;id,q,n,b&gt;
<span class="linenos">10</span>
<span class="linenos">11</span>if activep = true then
<span class="linenos">12</span>if n=0 then
<span class="linenos">13</span>   send &lt;id,q,1,b&gt;;
<span class="linenos">14</span>end if
<span class="linenos">15</span>neighb-idp[n,b]← q;
<span class="linenos">16</span>if neighb-idp[n,parityp] ≠ \bot  for n=0 and n=1 then
<span class="linenos">17</span>   perform procedure CompareIdsp;
<span class="linenos">18</span>end if
<span class="linenos">19</span>   send&lt;id,q,n,b&gt;;
<span class="linenos">20</span>end if
<span class="linenos">21</span>
<span class="linenos">22</span>Procedure CompareIdsp
<span class="linenos">23</span>if max{election-idp,neighb-idp[1,parityp]}&lt;neighb-idp[0,parityp] then
<span class="linenos">24</span>   election-idp ← neighb-idp[0,parityp];
<span class="linenos">25</span>   neighb-idp[n,parityp] ← ⊥ for n=0 and n=1; parityp ← ¬parityp;
<span class="linenos">26</span>   send&lt;id,election-idp,0,parityp&gt;;
<span class="linenos">27</span>   if neighb-idp[n,parityp] ≠ ⊥ for n=0 nad n=1 then
<span class="linenos">28</span>      perform procedure CompareIdsp;
<span class="linenos">29</span>   end if
<span class="linenos">30</span>else if neighb-idp[0,parityp] &lt; election-idp then
<span class="linenos">31</span>    activep←false;
<span class="linenos">32</span>else
<span class="linenos">33</span>    leaderp←true;
<span class="linenos">34</span>end if
<span class="linenos">35</span>
<span class="linenos">36</span>Echo Algorithm
<span class="linenos">37</span>
<span class="linenos">38</span>nat receivedp;
<span class="linenos">39</span>pro parentp;
<span class="linenos">40</span>If p is the iniaator
<span class="linenos">41</span>send&lt;wave&gt; to each r ∈ Neighborsp;
<span class="linenos">42</span>If p receives &lt;wave&gt; from a neighborr mess-queue
<span class="linenos">43</span>received ← receivedp+1;
<span class="linenos">44</span>if parentp= ⊥ and p is a noninitiator then
<span class="linenos">45</span>    parentp←q;
<span class="linenos">46</span>    if|Neighborsp|&gt;1 then
<span class="linenos">47</span>        send&lt;wave&gt; to each r ∈ Neighborsp \ {q};
<span class="linenos">48</span>    else
<span class="linenos">49</span>        send&lt;wave&gt; to q;
<span class="linenos">50</span>    end if
<span class="linenos">51</span>else if receivedp = |Neighborsp| then
<span class="linenos">52</span>    if parentp ≠ ⊥ then
<span class="linenos">53</span>        send &lt;wave&gt; to parentp;
<span class="linenos">54</span>    else
<span class="linenos">55</span>        decide;
<span class="linenos">56</span>    end if
<span class="linenos">57</span>end if
<span class="linenos">58</span>
<span class="linenos">59</span>
<span class="linenos">60</span>
<span class="linenos">61</span>
<span class="linenos">62</span>
<span class="linenos">63</span>markerp[c] for all incoming channels c of p;
<span class="linenos">64</span>mess-queue statep[c] for all incoming channels c of p;
<span class="linenos">65</span>
<span class="linenos">66</span>If p wants to initiate a snapshot
<span class="linenos">67</span>    perform procedure TakeSnapshotp;
<span class="linenos">68</span>
<span class="linenos">69</span>If p receives a basic message m through an incoming channel c0
<span class="linenos">70</span>if recordedp = true and markerp[c0] = false then
<span class="linenos">71</span>    statep[c0] ← append(statep[c0],m);
<span class="linenos">72</span>end if
<span class="linenos">73</span>
<span class="linenos">74</span>If p receives ⟨marker⟩ through an incoming channel c0
<span class="linenos">75</span>    perform procedure TakeSnapshotp;
<span class="linenos">76</span>    markerp[c0] ← true;
<span class="linenos">77</span>    if markerp[c] = true for all incoming channels c of p then
<span class="linenos">78</span>        terminate;
<span class="linenos">79</span>    end if
<span class="linenos">80</span>
<span class="linenos">81</span>Procedure TakeSnapshotp
<span class="linenos">82</span>if recordedp = false then
<span class="linenos">83</span>    recordedp ← true;
<span class="linenos">84</span>    send ⟨marker⟩ into each outgoing channel of p;
<span class="linenos">85</span>    take a local snapshot of the state of p;
<span class="linenos">86</span>end if
</pre></div>
</div>
</div>
<p><strong>Example</strong></p>
<p>DRAW FIGURES REPRESENTING THE EXAMPLE AND EXPLAIN USING THE FIGURE. Imagine a distributed system with three processes, labeled Process A, Process B, and Process C, connected by communication channels. When Process A initiates a snapshot, it sends a marker along its outgoing channel. Upon receiving the marker, Process B marks its local state and forwards the marker to Process C. Similarly, Process C marks its state upon receiving the marker. As the marker propagates back through the channels, each process records the messages it sends or receives after marking its state. Finally, once the marker returns to Process A, it collects the markers and recorded states from all processes to construct a consistent global snapshot of the distributed system. This example demonstrates how the Chandy-Lamport algorithm captures a snapshot without halting the system’s execution, facilitating analysis and debugging in distributed environments.</p>
<p><strong>Correctness:</strong></p>
<p><em>Termination (liveness)</em>: As each process initiates a snapshot and sends at most one marker message, the snapshot algorithm activity terminates within a finite timeframe. If process p has taken a snapshot by this point, and q is a neighbor of p, then q has also taken a snapshot. This is because the marker message sent by p has been received by q, prompting q to take a snapshot if it hadn’t already done so. Since at least one process initiated the algorithm, at least one process has taken a snapshot; moreover, the network’s connectivity ensures that all processes have taken a snapshot <a class="reference internal" href="#tel2001" id="id2"><span>[Tel2001]</span></a>.</p>
<p><em>Correctness</em>: We need to demonstrate that the resulting snapshot is feasible, meaning that each post-shot (basic) message is received during a post-shot event. Consider a post-shot message, denoted as m, sent from process p to process q. Before transmitting m, process p captured a local snapshot and dispatched a marker message to all its neighbors, including q. As the channels are FIFO (first-in-first-out), q received this marker message before receiving m. As per the algorithm’s protocol, q took its snapshot upon receiving this marker message or earlier. Consequently, the receipt of m by q constitutes a post-shot event <a class="reference internal" href="#tel2001" id="id3"><span>[Tel2001]</span></a>.</p>
<p><strong>Complexity:</strong></p>
<ol class="arabic simple">
<li><p><strong>Time Complexity</strong>  The Chandy-Lamport <span class="xref std std-ref">Algorithm</span> takes at most O(D) time units to complete where D is …</p></li>
<li><p><strong>Message Complexity:</strong> The Chandy-Lamport <span class="xref std std-ref">Algorithm</span> requires 2|E| control messages.</p></li>
</ol>
<p><strong>Lai-Yang Snapshot Algorithm:</strong></p>
<p>The Lai-Yang algorithm also captures a consistent global snapshot of a distributed system. Lai and Yang proposed a modification of Chandy-Lamport’s algorithm for distributed snapshot on a network of processes where the channels need not be FIFO. ALGORTHM, FURTHER DETAILS</p>
</div></blockquote>
<div role="list" class="citation-list">
<div class="citation" id="fokking2013" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Fokking2013</a><span class="fn-bracket">]</span></span>
<p>Wan Fokkink, Distributed Algorithms An Intuitive Approach, The MIT Press Cambridge, Massachusetts London, England, 2013</p>
</div>
<div class="citation" id="tel2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Tel2001<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>Gerard Tel, Introduction to Distributed Algorithms, CAMBRIDGE UNIVERSITY PRESS, 2001</p>
</div>
<div class="citation" id="lamport1985" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Lamport1985<span class="fn-bracket">]</span></span>
<p>Leslie Lamport, K. Mani Chandy: Distributed Snapshots: Determining Global States of a Distributed System. In: ACM Transactions on Computer Systems 3. Nr. 1, Februar 1985.</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="results.html" class="btn btn-neutral float-right" title="Implementation, Results and Discussion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Huseyin Sagirkaya.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>