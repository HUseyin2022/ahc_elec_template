from typing import List
import networkx as nx
from matplotlib import pyplot as plt

from datetime import datetime
from random import randint


class MessageManager:
    def __init__(self, delay_msg=False):
        self.processes = []
        self.messages = {}
        self.logs = []
        self.delay_msg = delay_msg
        self.message_count = 0
        self.initialised = False

    def initialise(self, processes):
        assert len(processes) >= 2
        assert not self.initialised

        self.processes = processes
        self.messages = {}
        for process in processes:
            self.messages[process.p_id] = []

        self.message_count = 0
        self.initialised = True

    def reset(self):
        self.initialised = False

    def has_message(self, p_id: int, msg_class=None) -> bool:
        """Checks if p has received a message"""
        assert (p_id in self.messages)
        return len([m for m in self.messages[p_id] if m['msg'].has_arrived() and
                    (msg_class is None or type(m['msg']) == msg_class)]) >= 1

    def fetch_message(self, p_id: int, msg_class=None) -> (int, Message):
        """Fetches process ids of message sent to p"""
        assert self.has_message(p_id, msg_class)
        available_msg = [m for m in self.messages[p_id] if m['msg'].has_arrived() and
                         (msg_class is None or type(m['msg']) == msg_class)]
        msg = available_msg[randint(0, len(available_msg) - 1)]  # Select a random message
        self.messages[p_id].remove(msg)  # Delete message
        return msg['s_id'], msg['msg']

    def add_message(self, from_id: int, to_id: int, msg: Message):
        """Adds message sent to q"""
        if self.delay_msg:
            msg.add_delay()
        self.messages[to_id].append({'s_id': from_id, 'msg': msg})
        self.message_count += 1

    def log(self, msg: str):
        """Adds message to logs"""
        self.logs.append(msg)

class GenericProcess:
    def __init__(self, process_id: int, msg_manager: MessageManager):
        self.p_id = process_id  # ID of current process
        self.msg_manager = msg_manager  # Message manager
        self.neigh = []  # Neighbours of current process
        self.initialised = False  # Not yet initialised

    def initiate(self):
        self.initialised = True

    def reset(self):
        self.initialised = False

    def add_neigh(self, neigh: int):
        """Adds neighbour to neighbours of process"""
        assert neigh not in self.neigh
        self.neigh.append(neigh)

    def receive(self, msg_class=None):
        """Gets the message received by the process"""
        while not self.msg_manager.has_message(self.p_id, msg_class):
            # Wait until p has received message
            pass

        # Fetch and return message for p
        return self.msg_manager.fetch_message(self.p_id, msg_class)

    def send(self, q_id: int, msg: Message = None):
        """Sends a message to process q"""
        if not msg:
            # Default to basic message with p_id
            msg = Message()
        self.msg_manager.add_message(from_id=self.p_id, to_id=q_id, msg=msg)

    def log(self, msg: str):
        """Logs a message"""
        self.msg_manager.log(f"{self}: {msg}")

    def __str__(self):
        return f"Process <{self.p_id}>"



def time() -> float:
    """Gets the current timestamp"""
    dt = datetime.now()
    ts = datetime.timestamp(dt)
    return ts


class Message:
    """Basic <tok> message"""
    def __init__(self):
        self.delay = time()

    def add_delay(self):
        """Adds random delay of upto 2 seconds to message delivery time"""
        self.delay += randint(0, 2000) / 1000

    def has_arrived(self) -> bool:
        """Checks if message has arrived"""
        return self.delay - time() < 0

    def __str__(self):
        return "<tok>"



def display_graph(graph: nx.Graph, title: str):
    """Draws the graph in a window"""
    nx.draw_networkx(graph)
    plt.title(title)
    plt.show()


def count_edges(processes: List[GenericProcess]) -> int:
    return sum(len(p.neigh) for p in processes) // 2